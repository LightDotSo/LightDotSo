# Copyright (C) 2023 Light, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

type AccountDeployed {
  id: Bytes!
  index: BigInt!
  userOpHash: Bytes!
  sender: Bytes!
  factory: Bytes!
  paymaster: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input AccountDeployed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  factory: Bytes
  factory_not: Bytes
  factory_gt: Bytes
  factory_lt: Bytes
  factory_gte: Bytes
  factory_lte: Bytes
  factory_in: [Bytes!]
  factory_not_in: [Bytes!]
  factory_contains: Bytes
  factory_not_contains: Bytes
  paymaster: Bytes
  paymaster_not: Bytes
  paymaster_gt: Bytes
  paymaster_lt: Bytes
  paymaster_gte: Bytes
  paymaster_lte: Bytes
  paymaster_in: [Bytes!]
  paymaster_not_in: [Bytes!]
  paymaster_contains: Bytes
  paymaster_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AccountDeployed_filter]
  or: [AccountDeployed_filter]
}

enum AccountDeployed_orderBy {
  id
  index
  userOpHash
  sender
  factory
  paymaster
  blockNumber
  blockTimestamp
  transactionHash
}

type BeforeExecution {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input BeforeExecution_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BeforeExecution_filter]
  or: [BeforeExecution_filter]
}

enum BeforeExecution_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Counter {
  id: String!
  userOpCount: BigInt!
  userOpRevertCount: BigInt!
  userOpSuccessCount: BigInt!
  walletCount: BigInt!
}

input Counter_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  userOpCount: BigInt
  userOpCount_not: BigInt
  userOpCount_gt: BigInt
  userOpCount_lt: BigInt
  userOpCount_gte: BigInt
  userOpCount_lte: BigInt
  userOpCount_in: [BigInt!]
  userOpCount_not_in: [BigInt!]
  userOpRevertCount: BigInt
  userOpRevertCount_not: BigInt
  userOpRevertCount_gt: BigInt
  userOpRevertCount_lt: BigInt
  userOpRevertCount_gte: BigInt
  userOpRevertCount_lte: BigInt
  userOpRevertCount_in: [BigInt!]
  userOpRevertCount_not_in: [BigInt!]
  userOpSuccessCount: BigInt
  userOpSuccessCount_not: BigInt
  userOpSuccessCount_gt: BigInt
  userOpSuccessCount_lt: BigInt
  userOpSuccessCount_gte: BigInt
  userOpSuccessCount_lte: BigInt
  userOpSuccessCount_in: [BigInt!]
  userOpSuccessCount_not_in: [BigInt!]
  walletCount: BigInt
  walletCount_not: BigInt
  walletCount_gt: BigInt
  walletCount_lt: BigInt
  walletCount_gte: BigInt
  walletCount_lte: BigInt
  walletCount_in: [BigInt!]
  walletCount_not_in: [BigInt!]
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Counter_filter]
  or: [Counter_filter]
}

enum Counter_orderBy {
  id
  userOpCount
  userOpRevertCount
  userOpSuccessCount
  walletCount
}

type Deposited {
  id: Bytes!
  account: Bytes!
  totalDeposit: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Deposited_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Deposited_filter]
  or: [Deposited_filter]
}

enum Deposited_orderBy {
  id
  account
  totalDeposit
  blockNumber
  blockTimestamp
  transactionHash
}

"""
8 bytes signed integer

"""
scalar Int8

type LightWallet {
  id: Bytes!
  index: BigInt!
  address: Bytes!
  imageHash: Bytes
  userOpHash: Bytes!
  sender: Bytes!
  factory: Bytes!
  paymaster: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  userOperations(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperation_orderBy
    orderDirection: OrderDirection
    where: UserOperation_filter
  ): [UserOperation!]
}

input LightWallet_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  imageHash: Bytes
  imageHash_not: Bytes
  imageHash_gt: Bytes
  imageHash_lt: Bytes
  imageHash_gte: Bytes
  imageHash_lte: Bytes
  imageHash_in: [Bytes!]
  imageHash_not_in: [Bytes!]
  imageHash_contains: Bytes
  imageHash_not_contains: Bytes
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  factory: Bytes
  factory_not: Bytes
  factory_gt: Bytes
  factory_lt: Bytes
  factory_gte: Bytes
  factory_lte: Bytes
  factory_in: [Bytes!]
  factory_not_in: [Bytes!]
  factory_contains: Bytes
  factory_not_contains: Bytes
  paymaster: Bytes
  paymaster_not: Bytes
  paymaster_gt: Bytes
  paymaster_lt: Bytes
  paymaster_gte: Bytes
  paymaster_lte: Bytes
  paymaster_in: [Bytes!]
  paymaster_not_in: [Bytes!]
  paymaster_contains: Bytes
  paymaster_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  userOperations: [String!]
  userOperations_not: [String!]
  userOperations_contains: [String!]
  userOperations_contains_nocase: [String!]
  userOperations_not_contains: [String!]
  userOperations_not_contains_nocase: [String!]
  userOperations_: UserOperation_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LightWallet_filter]
  or: [LightWallet_filter]
}

enum LightWallet_orderBy {
  id
  index
  address
  imageHash
  userOpHash
  sender
  factory
  paymaster
  blockNumber
  blockTimestamp
  transactionHash
  userOperations
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  accountDeployed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountDeployed
  accountDeployeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountDeployed_orderBy
    orderDirection: OrderDirection
    where: AccountDeployed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountDeployed!]!
  beforeExecution(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BeforeExecution
  beforeExecutions(
    skip: Int = 0
    first: Int = 100
    orderBy: BeforeExecution_orderBy
    orderDirection: OrderDirection
    where: BeforeExecution_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BeforeExecution!]!
  deposited(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposited
  depositeds(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposited_orderBy
    orderDirection: OrderDirection
    where: Deposited_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposited!]!
  signatureAggregatorChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SignatureAggregatorChanged
  signatureAggregatorChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SignatureAggregatorChanged_orderBy
    orderDirection: OrderDirection
    where: SignatureAggregatorChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SignatureAggregatorChanged!]!
  stakeLocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLocked
  stakeLockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLocked_orderBy
    orderDirection: OrderDirection
    where: StakeLocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLocked!]!
  stakeUnlocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeUnlocked
  stakeUnlockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeUnlocked_orderBy
    orderDirection: OrderDirection
    where: StakeUnlocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeUnlocked!]!
  stakeWithdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawn
  stakeWithdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawn_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawn!]!
  userOperationEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperationEvent
  userOperationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperationEvent_orderBy
    orderDirection: OrderDirection
    where: UserOperationEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperationEvent!]!
  userOperationRevertReason(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperationRevertReason
  userOperationRevertReasons(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperationRevertReason_orderBy
    orderDirection: OrderDirection
    where: UserOperationRevertReason_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperationRevertReason!]!
  withdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawn
  withdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawn_orderBy
    orderDirection: OrderDirection
    where: Withdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawn!]!
  userOperation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperation
  userOperations(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperation_orderBy
    orderDirection: OrderDirection
    where: UserOperation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperation!]!
  lightWallet(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LightWallet
  lightWallets(
    skip: Int = 0
    first: Int = 100
    orderBy: LightWallet_orderBy
    orderDirection: OrderDirection
    where: LightWallet_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LightWallet!]!
  counter(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Counter
  counters(
    skip: Int = 0
    first: Int = 100
    orderBy: Counter_orderBy
    orderDirection: OrderDirection
    where: Counter_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Counter!]!
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type SignatureAggregatorChanged {
  id: Bytes!
  aggregator: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SignatureAggregatorChanged_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  aggregator: Bytes
  aggregator_not: Bytes
  aggregator_gt: Bytes
  aggregator_lt: Bytes
  aggregator_gte: Bytes
  aggregator_lte: Bytes
  aggregator_in: [Bytes!]
  aggregator_not_in: [Bytes!]
  aggregator_contains: Bytes
  aggregator_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SignatureAggregatorChanged_filter]
  or: [SignatureAggregatorChanged_filter]
}

enum SignatureAggregatorChanged_orderBy {
  id
  aggregator
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeLocked {
  id: Bytes!
  account: Bytes!
  totalStaked: BigInt!
  unstakeDelaySec: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeLocked_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  totalStaked: BigInt
  totalStaked_not: BigInt
  totalStaked_gt: BigInt
  totalStaked_lt: BigInt
  totalStaked_gte: BigInt
  totalStaked_lte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_not_in: [BigInt!]
  unstakeDelaySec: BigInt
  unstakeDelaySec_not: BigInt
  unstakeDelaySec_gt: BigInt
  unstakeDelaySec_lt: BigInt
  unstakeDelaySec_gte: BigInt
  unstakeDelaySec_lte: BigInt
  unstakeDelaySec_in: [BigInt!]
  unstakeDelaySec_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [StakeLocked_filter]
  or: [StakeLocked_filter]
}

enum StakeLocked_orderBy {
  id
  account
  totalStaked
  unstakeDelaySec
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeUnlocked {
  id: Bytes!
  account: Bytes!
  withdrawTime: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeUnlocked_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawTime: BigInt
  withdrawTime_not: BigInt
  withdrawTime_gt: BigInt
  withdrawTime_lt: BigInt
  withdrawTime_gte: BigInt
  withdrawTime_lte: BigInt
  withdrawTime_in: [BigInt!]
  withdrawTime_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [StakeUnlocked_filter]
  or: [StakeUnlocked_filter]
}

enum StakeUnlocked_orderBy {
  id
  account
  withdrawTime
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeWithdrawn {
  id: Bytes!
  account: Bytes!
  withdrawAddress: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeWithdrawn_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawAddress: Bytes
  withdrawAddress_not: Bytes
  withdrawAddress_gt: Bytes
  withdrawAddress_lt: Bytes
  withdrawAddress_gte: Bytes
  withdrawAddress_lte: Bytes
  withdrawAddress_in: [Bytes!]
  withdrawAddress_not_in: [Bytes!]
  withdrawAddress_contains: Bytes
  withdrawAddress_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [StakeWithdrawn_filter]
  or: [StakeWithdrawn_filter]
}

enum StakeWithdrawn_orderBy {
  id
  account
  withdrawAddress
  amount
  blockNumber
  blockTimestamp
  transactionHash
}

type Subscription {
  accountDeployed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountDeployed
  accountDeployeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountDeployed_orderBy
    orderDirection: OrderDirection
    where: AccountDeployed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountDeployed!]!
  beforeExecution(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BeforeExecution
  beforeExecutions(
    skip: Int = 0
    first: Int = 100
    orderBy: BeforeExecution_orderBy
    orderDirection: OrderDirection
    where: BeforeExecution_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BeforeExecution!]!
  deposited(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposited
  depositeds(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposited_orderBy
    orderDirection: OrderDirection
    where: Deposited_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposited!]!
  signatureAggregatorChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SignatureAggregatorChanged
  signatureAggregatorChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SignatureAggregatorChanged_orderBy
    orderDirection: OrderDirection
    where: SignatureAggregatorChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SignatureAggregatorChanged!]!
  stakeLocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLocked
  stakeLockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLocked_orderBy
    orderDirection: OrderDirection
    where: StakeLocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLocked!]!
  stakeUnlocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeUnlocked
  stakeUnlockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeUnlocked_orderBy
    orderDirection: OrderDirection
    where: StakeUnlocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeUnlocked!]!
  stakeWithdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawn
  stakeWithdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawn_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawn!]!
  userOperationEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperationEvent
  userOperationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperationEvent_orderBy
    orderDirection: OrderDirection
    where: UserOperationEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperationEvent!]!
  userOperationRevertReason(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperationRevertReason
  userOperationRevertReasons(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperationRevertReason_orderBy
    orderDirection: OrderDirection
    where: UserOperationRevertReason_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperationRevertReason!]!
  withdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawn
  withdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawn_orderBy
    orderDirection: OrderDirection
    where: Withdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawn!]!
  userOperation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOperation
  userOperations(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOperation_orderBy
    orderDirection: OrderDirection
    where: UserOperation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOperation!]!
  lightWallet(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LightWallet
  lightWallets(
    skip: Int = 0
    first: Int = 100
    orderBy: LightWallet_orderBy
    orderDirection: OrderDirection
    where: LightWallet_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LightWallet!]!
  counter(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Counter
  counters(
    skip: Int = 0
    first: Int = 100
    orderBy: Counter_orderBy
    orderDirection: OrderDirection
    where: Counter_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Counter!]!
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type UserOperation {
  id: Bytes!
  index: BigInt!
  sender: Bytes!
  nonce: BigInt!
  initCode: Bytes!
  callData: Bytes!
  callGasLimit: BigInt!
  verificationGasLimit: BigInt!
  preVerificationGas: BigInt!
  maxFeePerGas: BigInt!
  maxPriorityFeePerGas: BigInt!
  paymasterAndData: Bytes!
  signature: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  entryPoint: Bytes!
  lightWallet: LightWallet!
  userOperationEvent: UserOperationEvent
  userOperationRevertReason: UserOperationRevertReason
}

type UserOperationEvent {
  id: Bytes!
  index: BigInt!
  userOpHash: Bytes!
  sender: Bytes!
  paymaster: Bytes!
  nonce: BigInt!
  success: Boolean!
  actualGasCost: BigInt!
  actualGasUsed: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  userOperation: UserOperation!
}

input UserOperationEvent_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  paymaster: Bytes
  paymaster_not: Bytes
  paymaster_gt: Bytes
  paymaster_lt: Bytes
  paymaster_gte: Bytes
  paymaster_lte: Bytes
  paymaster_in: [Bytes!]
  paymaster_not_in: [Bytes!]
  paymaster_contains: Bytes
  paymaster_not_contains: Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  success: Boolean
  success_not: Boolean
  success_in: [Boolean!]
  success_not_in: [Boolean!]
  actualGasCost: BigInt
  actualGasCost_not: BigInt
  actualGasCost_gt: BigInt
  actualGasCost_lt: BigInt
  actualGasCost_gte: BigInt
  actualGasCost_lte: BigInt
  actualGasCost_in: [BigInt!]
  actualGasCost_not_in: [BigInt!]
  actualGasUsed: BigInt
  actualGasUsed_not: BigInt
  actualGasUsed_gt: BigInt
  actualGasUsed_lt: BigInt
  actualGasUsed_gte: BigInt
  actualGasUsed_lte: BigInt
  actualGasUsed_in: [BigInt!]
  actualGasUsed_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  userOperation: String
  userOperation_not: String
  userOperation_gt: String
  userOperation_lt: String
  userOperation_gte: String
  userOperation_lte: String
  userOperation_in: [String!]
  userOperation_not_in: [String!]
  userOperation_contains: String
  userOperation_contains_nocase: String
  userOperation_not_contains: String
  userOperation_not_contains_nocase: String
  userOperation_starts_with: String
  userOperation_starts_with_nocase: String
  userOperation_not_starts_with: String
  userOperation_not_starts_with_nocase: String
  userOperation_ends_with: String
  userOperation_ends_with_nocase: String
  userOperation_not_ends_with: String
  userOperation_not_ends_with_nocase: String
  userOperation_: UserOperation_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UserOperationEvent_filter]
  or: [UserOperationEvent_filter]
}

enum UserOperationEvent_orderBy {
  id
  index
  userOpHash
  sender
  paymaster
  nonce
  success
  actualGasCost
  actualGasUsed
  blockNumber
  blockTimestamp
  transactionHash
  userOperation
  userOperation__id
  userOperation__index
  userOperation__sender
  userOperation__nonce
  userOperation__initCode
  userOperation__callData
  userOperation__callGasLimit
  userOperation__verificationGasLimit
  userOperation__preVerificationGas
  userOperation__maxFeePerGas
  userOperation__maxPriorityFeePerGas
  userOperation__paymasterAndData
  userOperation__signature
  userOperation__blockNumber
  userOperation__blockTimestamp
  userOperation__transactionHash
  userOperation__entryPoint
}

type UserOperationRevertReason {
  id: Bytes!
  index: BigInt!
  userOpHash: Bytes!
  sender: Bytes!
  nonce: BigInt!
  revertReason: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  userOperation: UserOperation!
}

input UserOperationRevertReason_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  revertReason: Bytes
  revertReason_not: Bytes
  revertReason_gt: Bytes
  revertReason_lt: Bytes
  revertReason_gte: Bytes
  revertReason_lte: Bytes
  revertReason_in: [Bytes!]
  revertReason_not_in: [Bytes!]
  revertReason_contains: Bytes
  revertReason_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  userOperation: String
  userOperation_not: String
  userOperation_gt: String
  userOperation_lt: String
  userOperation_gte: String
  userOperation_lte: String
  userOperation_in: [String!]
  userOperation_not_in: [String!]
  userOperation_contains: String
  userOperation_contains_nocase: String
  userOperation_not_contains: String
  userOperation_not_contains_nocase: String
  userOperation_starts_with: String
  userOperation_starts_with_nocase: String
  userOperation_not_starts_with: String
  userOperation_not_starts_with_nocase: String
  userOperation_ends_with: String
  userOperation_ends_with_nocase: String
  userOperation_not_ends_with: String
  userOperation_not_ends_with_nocase: String
  userOperation_: UserOperation_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UserOperationRevertReason_filter]
  or: [UserOperationRevertReason_filter]
}

enum UserOperationRevertReason_orderBy {
  id
  index
  userOpHash
  sender
  nonce
  revertReason
  blockNumber
  blockTimestamp
  transactionHash
  userOperation
  userOperation__id
  userOperation__index
  userOperation__sender
  userOperation__nonce
  userOperation__initCode
  userOperation__callData
  userOperation__callGasLimit
  userOperation__verificationGasLimit
  userOperation__preVerificationGas
  userOperation__maxFeePerGas
  userOperation__maxPriorityFeePerGas
  userOperation__paymasterAndData
  userOperation__signature
  userOperation__blockNumber
  userOperation__blockTimestamp
  userOperation__transactionHash
  userOperation__entryPoint
}

input UserOperation_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  initCode: Bytes
  initCode_not: Bytes
  initCode_gt: Bytes
  initCode_lt: Bytes
  initCode_gte: Bytes
  initCode_lte: Bytes
  initCode_in: [Bytes!]
  initCode_not_in: [Bytes!]
  initCode_contains: Bytes
  initCode_not_contains: Bytes
  callData: Bytes
  callData_not: Bytes
  callData_gt: Bytes
  callData_lt: Bytes
  callData_gte: Bytes
  callData_lte: Bytes
  callData_in: [Bytes!]
  callData_not_in: [Bytes!]
  callData_contains: Bytes
  callData_not_contains: Bytes
  callGasLimit: BigInt
  callGasLimit_not: BigInt
  callGasLimit_gt: BigInt
  callGasLimit_lt: BigInt
  callGasLimit_gte: BigInt
  callGasLimit_lte: BigInt
  callGasLimit_in: [BigInt!]
  callGasLimit_not_in: [BigInt!]
  verificationGasLimit: BigInt
  verificationGasLimit_not: BigInt
  verificationGasLimit_gt: BigInt
  verificationGasLimit_lt: BigInt
  verificationGasLimit_gte: BigInt
  verificationGasLimit_lte: BigInt
  verificationGasLimit_in: [BigInt!]
  verificationGasLimit_not_in: [BigInt!]
  preVerificationGas: BigInt
  preVerificationGas_not: BigInt
  preVerificationGas_gt: BigInt
  preVerificationGas_lt: BigInt
  preVerificationGas_gte: BigInt
  preVerificationGas_lte: BigInt
  preVerificationGas_in: [BigInt!]
  preVerificationGas_not_in: [BigInt!]
  maxFeePerGas: BigInt
  maxFeePerGas_not: BigInt
  maxFeePerGas_gt: BigInt
  maxFeePerGas_lt: BigInt
  maxFeePerGas_gte: BigInt
  maxFeePerGas_lte: BigInt
  maxFeePerGas_in: [BigInt!]
  maxFeePerGas_not_in: [BigInt!]
  maxPriorityFeePerGas: BigInt
  maxPriorityFeePerGas_not: BigInt
  maxPriorityFeePerGas_gt: BigInt
  maxPriorityFeePerGas_lt: BigInt
  maxPriorityFeePerGas_gte: BigInt
  maxPriorityFeePerGas_lte: BigInt
  maxPriorityFeePerGas_in: [BigInt!]
  maxPriorityFeePerGas_not_in: [BigInt!]
  paymasterAndData: Bytes
  paymasterAndData_not: Bytes
  paymasterAndData_gt: Bytes
  paymasterAndData_lt: Bytes
  paymasterAndData_gte: Bytes
  paymasterAndData_lte: Bytes
  paymasterAndData_in: [Bytes!]
  paymasterAndData_not_in: [Bytes!]
  paymasterAndData_contains: Bytes
  paymasterAndData_not_contains: Bytes
  signature: Bytes
  signature_not: Bytes
  signature_gt: Bytes
  signature_lt: Bytes
  signature_gte: Bytes
  signature_lte: Bytes
  signature_in: [Bytes!]
  signature_not_in: [Bytes!]
  signature_contains: Bytes
  signature_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  entryPoint: Bytes
  entryPoint_not: Bytes
  entryPoint_gt: Bytes
  entryPoint_lt: Bytes
  entryPoint_gte: Bytes
  entryPoint_lte: Bytes
  entryPoint_in: [Bytes!]
  entryPoint_not_in: [Bytes!]
  entryPoint_contains: Bytes
  entryPoint_not_contains: Bytes
  lightWallet_: LightWallet_filter
  userOperationEvent_: UserOperationEvent_filter
  userOperationRevertReason_: UserOperationRevertReason_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UserOperation_filter]
  or: [UserOperation_filter]
}

enum UserOperation_orderBy {
  id
  index
  sender
  nonce
  initCode
  callData
  callGasLimit
  verificationGasLimit
  preVerificationGas
  maxFeePerGas
  maxPriorityFeePerGas
  paymasterAndData
  signature
  blockNumber
  blockTimestamp
  transactionHash
  entryPoint
  lightWallet
  lightWallet__id
  lightWallet__index
  lightWallet__address
  lightWallet__imageHash
  lightWallet__userOpHash
  lightWallet__sender
  lightWallet__factory
  lightWallet__paymaster
  lightWallet__blockNumber
  lightWallet__blockTimestamp
  lightWallet__transactionHash
  userOperationEvent
  userOperationEvent__id
  userOperationEvent__index
  userOperationEvent__userOpHash
  userOperationEvent__sender
  userOperationEvent__paymaster
  userOperationEvent__nonce
  userOperationEvent__success
  userOperationEvent__actualGasCost
  userOperationEvent__actualGasUsed
  userOperationEvent__blockNumber
  userOperationEvent__blockTimestamp
  userOperationEvent__transactionHash
  userOperationRevertReason
  userOperationRevertReason__id
  userOperationRevertReason__index
  userOperationRevertReason__userOpHash
  userOperationRevertReason__sender
  userOperationRevertReason__nonce
  userOperationRevertReason__revertReason
  userOperationRevertReason__blockNumber
  userOperationRevertReason__blockTimestamp
  userOperationRevertReason__transactionHash
}

type Withdrawn {
  id: Bytes!
  account: Bytes!
  withdrawAddress: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Withdrawn_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawAddress: Bytes
  withdrawAddress_not: Bytes
  withdrawAddress_gt: Bytes
  withdrawAddress_lt: Bytes
  withdrawAddress_gte: Bytes
  withdrawAddress_lte: Bytes
  withdrawAddress_in: [Bytes!]
  withdrawAddress_not_in: [Bytes!]
  withdrawAddress_contains: Bytes
  withdrawAddress_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Withdrawn_filter]
  or: [Withdrawn_filter]
}

enum Withdrawn_orderBy {
  id
  account
  withdrawAddress
  amount
  blockNumber
  blockTimestamp
  transactionHash
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes
  """
  The block number
  """
  number: Int!
  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block

  """
  block: _Block_!
  """
  The deployment ID
  """
  deployment: String!
  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

