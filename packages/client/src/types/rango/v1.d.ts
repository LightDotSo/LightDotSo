/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/tx/report-tx": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Report Failed TX
     * @description Use it when user rejects the transaction in wallet or wallet fails to handle transaction. Calling this endpoint is not required, but is useful for reporting and we recommend to call it.
     */
    post: operations["reportTransaction"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tx/create": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create TX
     * @description When user starts swapping or when a step of swap succeeds, to get the transaction for the next step, this endpoint should be called.
     */
    post: operations["createTransaction"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tx/check-status": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check TX Status
     * @description After that user signed a transaction on his/her wallet you should call this endpoint periodically to see that transaction's status.
     */
    post: operations["checkTxStatus"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/routing/confirm": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Route Confirmation
     * @description User should select the desired route and wallets to confirm the route
     */
    post: operations["confirmSwap"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/routing/bests": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Best Routes
     * @description It goes through all the possible DEX & bridges to find the best possible routes based on user experience, fee amount, and output of swap.
     */
    post: operations["getBestRoutes"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/routing/best": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get The Best Route
     * @description It goes through all the possible DEX & bridges to find the best possible route based on user experience, fee amount, and output of swap.
     */
    post: operations["getBestRoute"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/wallets/token-balance": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Token Balance
     * @description Get balance of the given wallet address for a specific token.
     */
    get: operations["getTokenBalance"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/wallets/details": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Balance
     * @description Get all tokens' balances for the given wallet address.
     */
    get: operations["getWalletDetails"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tx/{requestId}/check-approval": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Check Approval TX Status
     * @description When createTransaction returns an approve transaction, and user signs that tx, you should periodically call check-approval to see if the approval tx is completed. After a successful check, you should call createTransaction again to receive the main transaction.
     */
    get: operations["checkApproval"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/meta": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Metadata (tokens, swappers, blockchains)
     * @description This service fetches all the required data to fill the swap UI, including list of all tokens, swappers (DEXes & Bridges), and all blockchains' metadata.
     */
    get: operations["getAllMeta"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/meta/swappers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Swappers Metadata
     * @description Metadata of all swappers
     */
    get: operations["getSwappers"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/meta/compact": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Compact Metadata
     * @description This service fetches all the required data to fill the swap UI, including a list of all tokens, swappers (DEX & Bridges), and all blockchains' metadata in a compact format, which could be used to draw a path diagram similar to the Rango main app.
     */
    get: operations["getAllMetaCompact"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/meta/blockchains": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Blockchains Metadata
     * @description Metadata of all blockchains
     */
    get: operations["getBlockchains"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    BaseResponse: {
      error?: Record<string, never>;
      /** Format: int32 */
      errorCode?: number;
      /** Format: int32 */
      traceId?: number;
    };
    /** @description Request body */
    ReportTransactionRequest: {
      /**
       * @description RequestId from best route endpoint
       * @example 688b308e-a06b-4a4e-a837-220d458b8642
       */
      requestId: string;
      /**
       * @description Type of the event that happened
       * @example TX_FAIL
       * @enum {string}
       */
      eventType:
        | "FETCH_TX_FAILED"
        | "USER_REJECT"
        | "USER_CANCEL"
        | "CALL_WALLET_FAILED"
        | "SEND_TX_FAILED"
        | "CLIENT_UNEXPECTED_BEHAVIOUR"
        | "TX_EXPIRED"
        | "INSUFFICIENT_APPROVE"
        | "USER_CANCELED_TX"
        | "CALL_OR_SEND_FAILED"
        | "TX_FAILED_IN_BLOCKCHAIN";
      /**
       * Format: int32
       * @description 1-based step number of a complex multi-step swap
       * @example 1
       */
      step?: number;
      /**
       * @deprecated
       * @description A list of key-value for extra details. (String to String map). it is deprecated
       * @example {
       *       "message": "user rejected the transaction"
       *     }
       */
      data?: {
        [key: string]: string | undefined;
      };
      /** @description Reason of problem in transaction */
      reason?: string;
      /** @description List of tags */
      tags?: {
        [key: string]: string | undefined;
      };
    };
    /** @description Request body */
    CreateTransactionRequest: {
      /**
       * @description Unique requestId received from bestRoute endpoint
       * @example 1978d8fa-335d-4915-a039-77f1a17315f5
       */
      requestId: string;
      /**
       * Format: int32
       * @description Number of current step, starting from 1
       * @example 1
       */
      step: number;
      userSettings: components["schemas"]["UserSettings"];
      validations: components["schemas"]["CreateTransactionValidation"];
    };
    /** @description List of validations that Rango should do */
    CreateTransactionValidation: {
      /** @description If true [Recommended], Rango will check that user has the required balance for swap */
      balance: boolean;
      /** @description If true [Recommended], Rango will check that user has the required fees in the wallet */
      fee: boolean;
      /**
       * @description If true [Recommended], Rango will check that user has the required allowance for tx
       * @example true
       */
      approve: boolean;
    };
    /** @description Settings of user for swaps */
    UserSettings: {
      /**
       * @description Amount of user's preferred slippage in percent
       * @example 8
       */
      slippage: number;
      /** @description If false [Recommended], Rango approve src token as much as input amount */
      infiniteApprove?: boolean;
    };
    /** @description An asset unique by triple of (blockchain, symbol, address) */
    Asset: {
      /**
       * @description The blockchain which this token belongs to
       * @example BSC
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description The display symbol, e.g. USDT, BTC, etc.
       * @example USDC
       */
      symbol: string;
      /**
       * @description Smart contract address of token, null for native tokens
       * @example 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d
       */
      address?: string;
    };
    /** @description An asset with its ticker */
    AssetWithTicker: {
      /**
       * @description Blockchain of asset
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description Symbol of an asset
       * @example BUSD
       */
      symbol: string;
      /**
       * @description Contract address of the asset, null for native tokens
       * @example bc1
       */
      address?: string;
      /** @description The ticker of the asset which normally is a combination of symbol and address, required by some javascript wallets */
      ticker: string;
    };
    Coin: {
      denom: string;
      amount: string;
    };
    /** @description A real cosmos message, most fields of this object should be directly passed to wallet for signing by user, the important part is `msgs` field that contains all the cosmos actions that should be performed. */
    CosmosMessage: {
      chainId?: string;
      /** Format: int64 */
      account_number?: number;
      sequence?: number;
      msgs: components["schemas"]["Msg"][];
      protoMsgs: components["schemas"]["ProtoMsg"][];
      memo?: string;
      /** Format: int32 */
      source?: number;
      fee?: components["schemas"]["CosmosStdFee"];
      /**
       * @description Sign type is important field to consider, you should use AMINO or DIRECT mode of wallet depending on value of this field
       * @enum {string}
       */
      signType: "AMINO" | "DIRECT";
      rpcUrl?: string;
    };
    /** @description An alternative to CosmosMessage object for the cosmos wallets that do not support generic Cosmos messages */
    CosmosRawTransferData: {
      /**
       * @description The method value
       * @example transfer
       */
      method: string;
      asset: components["schemas"]["AssetWithTicker"];
      /**
       * @description The machine-readable amount to transfer
       * @example 1000000000000000000
       */
      amount: number;
      /**
       * Format: int32
       * @description The decimals for this asset
       * @example 18
       */
      decimals: number;
      /** @description The recipient address of transaction */
      recipient: string;
      /** @description Memo of transaction, can be null */
      memo?: string;
    };
    CosmosStdFee: {
      gas: string;
      amount: components["schemas"]["Coin"][];
    };
    /** @description A Cosmos transaction, child of GenericTransaction */
    CosmosTransaction: {
      type: "CosmosTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /** @description Address of wallet that this transaction should be executed in, same as the create transaction request's input */
      fromWalletAddress: string;
      /**
       * @description The blockchain that this transaction will be executed in, same as the input blockchainof create transaction
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      data: components["schemas"]["CosmosMessage"];
      rawTransfer?: components["schemas"]["CosmosRawTransferData"];
    });
    /** @description Transaction created by Rango */
    CreateTransactionResponse: {
      /** @description If true, Rango has created a non-null transaction and error message is null */
      ok: boolean;
      /** @description Error message about the incident if ok == false */
      error?: string;
      /**
       * Format: int32
       * @description Error code about the incident if ok == false
       */
      errorCode?: number;
      /**
       * Format: int32
       * @description Trace id about incident if ok == false
       */
      traceId?: number;
      transaction?:
        | components["schemas"]["CosmosTransaction"]
        | components["schemas"]["EvmTransaction"]
        | components["schemas"]["SolanaTransaction"]
        | components["schemas"]["StarkNetTransaction"]
        | components["schemas"]["TransferTransaction"]
        | components["schemas"]["TrxTransaction"];
    };
    /** @description The transaction object for all EVM-based blockchains, including Ethereum, BSC, Polygon, Harmony, etc. */
    EvmTransaction: {
      type: "EvmTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /**
       * @description The blockchain that this transaction is going to run in
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /** @description Determines that this transaction is an approval transaction or not, if true user should approve the transaction and call `create transaction` endpoint again to get the original tx. Beware that most of the fields of this object will be passed directly to the wallet without any change. */
      isApprovalTx: boolean;
      /** @description The source wallet address, it can be null */
      from: string;
      /** @description Address of destination wallet or the smart contract or token that is going to be called */
      to: string;
      /** @description The data of smart contract call, it can be null in case of native token transfer */
      data?: string;
      /** @description The amount of transaction in case of native token transfer */
      value?: string;
      /** @description Recommended gas limit for transaction */
      gasLimit?: string;
      /** @description Recommended gas price for transaction (Null for Ethereum) */
      gasPrice?: number;
      /** @description Recommended max priority gas price (only for Ethereum) */
      maxPriorityFeePerGas?: number;
      /** @description Max gas price for Ethereum (max value for BaseGasPrice+PriorityGasPrice) */
      maxFeePerGas?: number;
      /** @description Recommended nonce for transaction */
      nonce?: number;
    });
    /** @description Transaction's raw data */
    GenericTransaction: {
      /**
       * @description Blockchain transaction type. e.g. EVM
       * @enum {string}
       */
      type:
        | "EVM"
        | "TRANSFER"
        | "COSMOS"
        | "SOLANA"
        | "ZK_ROLLUP"
        | "TRON"
        | "STARKNET";
    };
    Msg: Record<string, never>;
    ProtoMsg: {
      type_url: string;
      value: number[];
    };
    /** @description List of instructions */
    SolanaInstruction: {
      keys: components["schemas"]["SolanaInstructionKey"][];
      programId: string;
      /** Format: byte */
      data: string;
    };
    SolanaInstructionKey: {
      pubkey: string;
      isSigner: boolean;
      isWritable: boolean;
    };
    /** @description List of signatures. fills only if message is already partially signed */
    SolanaSignature: {
      publicKey: string;
      /** Format: byte */
      signature: string;
    };
    /** @description Solana transaction including multiple instructions */
    SolanaTransaction: {
      type: "SolanaTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /**
       * @description Transaction blockchain
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /** @description Wallet address of transaction initiator */
      from: string;
      /** @description Transaction identifier in case of retry */
      identifier: string;
      /** @description List of instructions */
      instructions: components["schemas"]["SolanaInstruction"][];
      /** @description Recent blockHash. fills only if message is already partially signed */
      recentBlockhash?: string;
      /** @description List of signatures. fills only if message is already partially signed */
      signatures: components["schemas"]["SolanaSignature"][];
      /** Format: byte */
      serializedMessage?: string;
      /**
       * @description type of Solana transaction. available values are {LEGACY, VERSIONED}
       * @enum {string}
       */
      txType: "LEGACY" | "VERSIONED";
    });
    StarkNetTransaction: {
      type: "StarkNetTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /** @enum {string} */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /** @description List of calldata to sign a multiple transaction */
      calls: components["schemas"]["StarknetCallData"][];
      /** @description Max fee for transaction */
      maxFee?: number;
      /** @description Determines that this transaction is an approval transaction or not, if true user should approve the transaction and call `create transaction` endpoint again to get the original tx. Beware that most of the fields of this object will be passed directly to the wallet without any change. */
      isApprovalTx: boolean;
    });
    /** @description Single calldata to call a contract */
    StarknetCallData: {
      /** @description Contract address to call */
      contractAddress: string;
      /** @description Function name to call */
      entrypoint: string;
      /** @description Function inputs */
      calldata?: string[];
    };
    /** @description A simple transfer transaction. This type of transaction is used for non-EVM and non-Cosmos blockchains including BTC, LTC, BCH */
    TransferTransaction: {
      type: "TransferTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /** @description The method that should be passed to wallet including `deposit`, `transfer` */
      method: string;
      /** @description Source wallet address that can sign this transaction */
      fromWalletAddress: string;
      /** @description Destination wallet address that the fund should be sent to */
      recipientAddress?: string;
      /** @description The memo of transaction, can be null */
      memo?: string;
      /**
       * @description The machine-readable amount of transaction
       * @example 1000000000000000000
       */
      amount: number;
      /**
       * Format: int32
       * @description The decimals of the asset
       */
      decimals: number;
      asset: components["schemas"]["AssetWithTicker"];
      /** @description list of available utxo for wallet address */
      utxo: components["schemas"]["UtxoData"][];
    });
    /** @description The data of smart contract call */
    TrxRawData: Record<string, never>;
    TrxTransaction: {
      type: "TrxTransaction";
    } & (Omit<
      WithRequired<components["schemas"]["GenericTransaction"], "type">,
      "type"
    > & {
      /**
       * @description Transaction blockchain
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /** @description Determines that this transaction is an approval transaction or not, if true user should approve the transaction and call `create transaction` endpoint again to get the original tx. Beware that most of the fields of this object will be passed directly to the wallet without any change. */
      isApprovalTx: boolean;
      raw_data?: components["schemas"]["TrxRawData"];
      /** @description The hex data for smart contract call */
      raw_data_hex?: string;
      externalTxId?: string;
      /** @description The payload for wallet call */
      __payload__?: Record<string, never>;
      /** @description The txID for wallet call */
      txID: string;
      /** @description The visible for wallet call */
      visible: boolean;
    });
    /** @description list of available utxo for wallet address */
    UtxoData: {
      txId: string;
      /** Format: int32 */
      vOut?: number;
      script: string;
      value: number;
      /** Format: int32 */
      vout: number;
    };
    /** @description Request body */
    CheckTxStatusRequest: {
      /**
       * @description The unique ID generate in `best route` endpoint
       * @example b3a12c6d-86b8-4c21-97e4-809151dd4036
       */
      requestId: string;
      /**
       * @description Tx id that wallet returned
       * @example 0xfa88b705a5b4049adac7caff50c887d9600ef023ef1a937f8f8b6f44e90042b5
       */
      txId: string;
      /**
       * Format: int32
       * @description 1-based step number of a complex multi-step swap
       * @example 1
       */
      step: number;
    };
    /** @description A transaction's url that can be displayed to advanced user to track the progress */
    ExplorerUrl: {
      /**
       * @description Url of the transaction in bscscan/harmony explorer/plygonscan/etc.
       * @example https://etherscan.io/tx/0xa1a37ce2063c4764da27d990a22a0c89ed8ac585286a77aa02e1c1998203de19
       */
      url: string;
      /**
       * @description A custom display name to help user distinguish the transactions from eachother. Ex: `Inbound`, `Outbound`, `Bridge`, or null
       * @example Inbound
       */
      description?: string;
    };
    /** @description In cases that output is different from desired token */
    OutputToken: {
      /** @enum {string} */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      symbol: string;
      name?: string;
      isPopular: boolean;
      chainId?: string;
      address: string;
      /** Format: int32 */
      decimals: number;
      image: string;
      blockchainImage?: string;
      /** Format: double */
      usdPrice: number;
    };
    /** @description Data of referral rewards of a transaction */
    TransactionStatusReferral: {
      /**
       * @description The machine-readable amount of the reward
       * @example 1000000000000000000
       */
      amount: number;
      /**
       * @description The blockchain that reward is generated in
       * @example BSC
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description The symbol of the asset that is rewarded
       * @example ADA
       */
      symbol?: string;
      /**
       * @description The smart contract address of rewarded asset, null for native assets
       * @example 0x3ee2200efb3400fabb9aacf31297cbdd1d435d47
       */
      address?: string;
      /**
       * Format: int32
       * @description The decimals of the rewarded asset
       * @example 18
       */
      decimals?: number;
    };
    /** @description Response of `check transaction status` containing the latest status of transaction */
    TransactionStatusResponse: {
      /**
       * @description Status of the transaction, while the status is running, client should retry the check status
       * @example success
       * @enum {string}
       */
      status?: "running" | "failed" | "success";
      /** @description A message in case of failure, that can be shown to user */
      extraMessage?: string;
      /**
       * Format: int64
       * @description The timestamp of the final executed transaction. Beware that timestamp can be null even if the status is successful or failed
       * @example 1635271424813
       */
      timestamp?: number;
      /**
       * @description The output amount of the transaction if it was successful
       * @example 0.28
       */
      outputAmount?: number;
      /** @description List of explorer urls for the transactions that happened in this step. */
      explorerUrl?: components["schemas"]["ExplorerUrl"][];
      /** @description List of referral reward for the dApp and Rango */
      referrals?: components["schemas"]["TransactionStatusReferral"][];
      newTx?:
        | components["schemas"]["CosmosTransaction"]
        | components["schemas"]["EvmTransaction"]
        | components["schemas"]["SolanaTransaction"]
        | components["schemas"]["StarkNetTransaction"]
        | components["schemas"]["TransferTransaction"]
        | components["schemas"]["TrxTransaction"];
      /**
       * @description In some special cases [ex: AnySwap], user should follow some steps outside Rango to get its assets. You can show this to user as help
       * @example null
       */
      diagnosisUrl?: string;
      /** @description In some special cases [ex: Wormhole Bridge], user should sign multiple transactions for a step to succeed. in such cases you can use steps data and show internal steps of one swap to user */
      steps?: components["schemas"]["TransactionStepDetails"][];
      outputToken?: components["schemas"]["OutputToken"];
    };
    /** @description When user need to sign multiple transactions this data could be used to show internal steps of one swap to user */
    TransactionStepDetails: {
      /**
       * @description The step name
       * @example redeem
       */
      name: string;
      /**
       * @description Show the step state. e.g., PENDING, FAILED, etc.
       * @enum {string}
       */
      state:
        | "PENDING"
        | "CREATED"
        | "WAITING"
        | "SIGNED"
        | "SUCCESSED"
        | "FAILED";
      /** @description Show whether the swap is in this state or not. */
      current: boolean;
    };
    /** @description Request body */
    ConfirmSwapRequest: {
      /**
       * @description Unique requestId received from bestRoute endpoint
       * @example 1978d8fa-335d-4915-a039-77f1a17315f5
       */
      requestId: string;
      /**
       * @description The list of user's selected wallets to doing the swapping operation. (Blockchain to Wallet address map)
       * @default {}
       * @example {
       *       "ETH": "0x6f33bb1763eebead07cf8815a62fcd7b30311fa3"
       *     }
       */
      selectedWallets: {
        [key: string]: string | undefined;
      };
      /**
       * @description The address of custom destination wallet, in case that you want to just swap in a blockchain because selected wallets can not support this scenario
       * @default null
       * @example 0x6f33bb1763eebead07cf8815a62fcd7b30311fa3
       */
      destination: string;
    };
    /** @description The amount of an asset, including value & decimals. The amount is machine-readable, to make it human-readable it should be shifted by decimals. */
    Amount: {
      /**
       * @description The machine-readable amount shifted by decimals
       * @example 1000000000000000000
       */
      amount: number;
      /**
       * Format: int32
       * @description The decimals of the token in blockchain
       * @example 18
       */
      decimals: number;
    };
    /** @description The best route response was found by Rango. If the `result` field is null, the server hasn't found any route. */
    BestRouteResponse: {
      from: components["schemas"]["Asset"];
      to: components["schemas"]["Asset"];
      /**
       * @description The amount from request
       * @example 0.28
       */
      requestAmount: number;
      /**
       * @description The unique requestId generated for this request by server. It should be passed down to all other endpoints if this swap continues on
       * @example d10657ce-b13a-405c-825b-b47f8a5096aa
       */
      requestId: string;
      result?: components["schemas"]["SimulationResult"];
      /** @description list of best paths data, used only in multi routing */
      results?: components["schemas"]["MultiRouteSimulationResult"][];
      /** @description Pre-requisite check result, it will be null if request.checkPrerequisites is false */
      validationStatus?: components["schemas"]["BlockchainValidationStatus"][];
      /** @description A warning indicating that none of your wallets have the same blockchain as X asset */
      walletNotSupportingFromBlockchain: boolean;
      /** @description A warning that indicates that it took too much time to find the best route and server could not find any routes from X to Y */
      processingLimitReached: boolean;
      /** @description A warning if not empty, containing list of blockchains that user have no connected wallets for */
      missingBlockchains: (
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM"
      )[];
      /** @description A list of string messages that might be cause of not finding the route. It's just for display purposes */
      diagnosisMessages: string[];
      /**
       * @description Compare current response to previous response
       * @enum {string}
       */
      compareStatus:
        | "NOTHING_TO_COMPARE"
        | "PREVIOUS_NOT_FOUND"
        | "PREVIOUS_ROUTE_IS_EMPTY"
        | "ROUTE_IS_EMPTY"
        | "REQUESTS_NOT_MATCHED"
        | "IDENTICAL"
        | "SWAPPERS_CHANGED"
        | "TOKENS_CHANGED"
        | "SWAPPERS_AND_TOKENS_CHANGED"
        | "AMOUNT_CHANGED";
      /** @description The state of confirm swap */
      confirmSwapStatus?: boolean;
      /** @description Error occurred during creating swap */
      error?: string;
      /**
       * Format: int32
       * @description Error code show error type in rango
       */
      errorCode?: number;
      /**
       * Format: int32
       * @description Trace id help rang support to resolve issue
       */
      traceId?: number;
    };
    /** @description The blockchain that this validation data belongs to */
    BlockchainValidationStatus: {
      /**
       * @description The blockchain of validation
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /** @description The status of validation for all the wallets of the specific blockchain */
      wallets: components["schemas"]["WalletValidationStatus"][];
    };
    /** @description The best route response for multi routing endpoint was found by Rango. If the `result` field is null, the server hasn't found any route. */
    ConfirmSwapResponse: {
      /** @description If true, Rango has created a non-null transaction and error message is null */
      ok: boolean;
      /** @description Error message about the incident if ok == false */
      error?: string;
      /**
       * Format: int32
       * @description Error code about the incident if ok == false
       */
      errorCode?: number;
      /**
       * Format: int32
       * @description Error code about the incident if ok == false
       */
      traceId?: number;
      result?: components["schemas"]["BestRouteResponse"];
    };
    /** @description Meta data of evm network fee */
    EvmNetworkFeeMeta: {
      type: "EvmNetworkFeeMeta";
    } & (Omit<components["schemas"]["SwapFeeMeta"], "type"> & {
      gasLimit: number;
      gasPrice: number;
    });
    /** @description Full information of a path of multiple swaps that should be executed by user to swap X to Y */
    MultiRouteSimulationResult: {
      /**
       * @description The unique routeId generated for this route by server. It should be passed down to all other endpoints if this swap continues on
       * @example d10657ce-b13a-405c-825b-b47f8a5096aa
       */
      requestId: string;
      /**
       * @description The estimation of Rango from output amount of Y
       * @example 1.23
       */
      outputAmount: number;
      /** @description List of required swaps to swap X to Y with the expected outputAmount */
      swaps: components["schemas"]["SwapResult"][];
      /**
       * @description Indicates that result is OK or have some problems such as Price Impact issue. If there is a price impact issue Rango won't allow dApps to createTransaction and it will fail because of the risk of huge loss for user
       * @enum {string}
       */
      resultType:
        | "OK"
        | "HIGH_IMPACT"
        | "HIGH_IMPACT_FOR_CREATE_TX"
        | "INPUT_LIMIT_ISSUE"
        | "VIA_ETH";
      /** @description List of scores calculated for each preference aspect */
      scores: components["schemas"]["SimulationScore"][];
      /** @description List of tags attributed to each route considering every aspect */
      tags: components["schemas"]["MultiRoutingTag"][];
      /** @description Pre-requisite check result, it will be null if request.checkPrerequisites is false */
      validationStatus?: components["schemas"]["BlockchainValidationStatus"][];
      /** @description A warning indicating that none of your wallets have the same blockchain as X asset */
      walletNotSupportingFromBlockchain: boolean;
      /** @description A warning if not empty, containing list of blockchains that user have no connected wallets for */
      missingBlockchains: (
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM"
      )[];
    };
    /** @description The multi-routing result tag */
    MultiRoutingTag: {
      /** @description The human-readable label */
      label: string;
      /** @description The value of Tag */
      value: string;
    };
    /** @description Details of minimum required slippage of a step */
    RecommendedSlippage: {
      /**
       * @description If true, means that Rango failed to compute slippage for this step
       * @example true
       */
      error: boolean;
      /**
       * @description The slippage amount in percent
       * @example 8
       */
      slippage?: number;
    };
    /** @description Full information of a path of multiple swaps that should be executed by user to swap X to Y */
    SimulationResult: {
      /**
       * @description The estimation of Rango from output amount of Y
       * @example 1.23
       */
      outputAmount: number;
      /** @description List of required swaps to swap X to Y with the expected outputAmount */
      swaps: components["schemas"]["SwapResult"][];
      /**
       * @description Indicates that result is OK or have some problems such as Price Impact issue. If there is a price impact issue Rango won't allow dApps to createTransaction and it will fail because of the risk of huge loss for user
       * @enum {string}
       */
      resultType:
        | "OK"
        | "HIGH_IMPACT"
        | "HIGH_IMPACT_FOR_CREATE_TX"
        | "INPUT_LIMIT_ISSUE"
        | "VIA_ETH";
    };
    /** @description Score calculated for each preference for sorting in UI */
    SimulationScore: {
      /**
       * @description type of evaluated aspect
       * @enum {string}
       */
      preferenceType:
        | "PRICE"
        | "RELIABILITY"
        | "NET_OUTPUT"
        | "SPEED"
        | "SMART"
        | "FEE";
      /**
       * Format: int64
       * @description value of score (typically between 0 to 100)
       */
      score: number;
    };
    /** @description A fee unit, including the type of asset and the amount of fee */
    SwapFee: {
      asset: components["schemas"]["Asset"];
      /**
       * @description The type of fee
       * @example FROM_SOURCE_WALLET
       * @enum {string}
       */
      expenseType:
        | "FROM_SOURCE_WALLET"
        | "DECREASE_FROM_OUTPUT"
        | "FROM_DESTINATION_WALLET";
      /**
       * @description The human readable amount of fee
       * @example 0.004
       */
      amount: number;
      /**
       * @description A display name for this fee
       * @example Network fee
       */
      name: string;
      meta?: components["schemas"]["EvmNetworkFeeMeta"];
      /**
       * Format: double
       * @description The price of fee token
       * @example 1.1
       */
      price?: number;
    };
    /** @description Meta data of swap fee */
    SwapFeeMeta: {
      type: string;
    };
    /** @description A node of the path */
    SwapNode: {
      /**
       * @description Name of the market
       * @example Uniswap
       */
      marketName: string;
      /**
       * @description Id of market
       * @example Uniswap
       */
      marketId?: string;
      /**
       * Format: double
       * @description Percent of the allocation to this path
       * @example 45
       */
      percent: number;
      /**
       * @description Pool Ids
       * @example 0x323afe...3e2
       */
      pools: string[];
      /**
       * @description Input amount for this part of route
       * @example 5400000000000000
       */
      inputAmount?: number;
      /**
       * @description output amount for this part of route
       * @example 2300000000000
       */
      outputAmount?: number;
    };
    /** @description A step of a multi-step swap */
    SwapResult: {
      /**
       * @description Id of the DEX or bridge that will handle this step. This id can be used to lookup in the meta service for showing icon and display name of the service
       * @example OneInchBsc
       */
      swapperId: string;
      /** @description Logo of swapper */
      swapperLogo: string;
      /**
       * @description Type of the swapper
       * @example DEX
       * @enum {string}
       */
      swapperType: "BRIDGE" | "DEX" | "AGGREGATOR" | "OFF_CHAIN";
      from: components["schemas"]["SwapResultAsset"];
      to: components["schemas"]["SwapResultAsset"];
      /**
       * @description Estimated input amount of this step. Can be used for previewing to user and should not be used for real computation, since it may change when the real transaction happens due to volatility of the market
       * @example 1.2
       */
      fromAmount: number;
      /** @description The minimum amount unit, the precision that will be applied to transaction amount in `create transaction` endpoint automatically by Rango. This field is informational and there is no need to apply it in client-side */
      fromAmountPrecision?: number;
      /**
       * @description Minimum required amount of the source asset of this step. It's a limitation from DEX orbridge that is executing this step. ex: Binance Bridge needs min of 234 MATIC for swapping MATIC from BSC to POLYGON. Beware that if fromAmount < fromAmountMinValue you should not let user start the swap. Null value indicates that there is no limitation.
       * @example 1.34
       */
      fromAmountMinValue?: number;
      /**
       * @description Exactly the same as fromAmountMinValue, but for the maximum limit
       * @example 2.89
       */
      fromAmountMaxValue?: number;
      /**
       * @description Specifies range for fromAmount(Min/Max)Value. for example if value is EXCLUSIVE and fromAmountMinValue is 20, user can execute transaction if inputValue>20, but for INCLUSIVE inputValue>=20 is valid
       * @example INCLUSIVE/EXCLUSIVE
       * @enum {string}
       */
      fromAmountRestrictionType?: "INCLUSIVE" | "EXCLUSIVE";
      /**
       * @description Estimated output amount of this step
       * @example 1.8
       */
      toAmount: number;
      /** @description List of fees that are taken from user in this step */
      fee: components["schemas"]["SwapFee"][];
      /**
       * Format: int32
       * @description The estimated time (in seconds) that this step might take, beware that this number is just an estimation and should be used for previewing
       * @example 120
       */
      estimatedTimeInSeconds: number;
      /**
       * @description The type of swapping that indicates this swap is happening inside a blockchain or is between two different blockchains
       * @example INTER_CHAIN
       * @enum {string}
       */
      swapChainType: "INTER_CHAIN" | "INTRA_CHAIN";
      /** @description The internal routing of this step showing how the initial swap request will be split and executed. This can be used for previewing purpose to give the user a sense of what's going to happen. Null indicates that there is no internal mechanism and swapping is simple and straightforward */
      routes?: components["schemas"]["SwapRoute"][];
      recommendedSlippage?: components["schemas"]["RecommendedSlippage"];
      /** @description Warnings like slow transactions. you must show this to users */
      warnings?: string[];
      timeStat?: components["schemas"]["SwapperTimeStat"];
      /** @description User should provide wallet in destination if this is true. it happens where swap includes claim tx */
      includesDestinationTx: boolean;
      /**
       * Format: int32
       * @description specifies maximum messages that the user must sign, without considering approve transactions
       */
      maxRequiredSign: number;
    };
    /** @description Source or destination asset of a step */
    SwapResultAsset: {
      /**
       * @description Symbol of the source asset of this step
       * @example OSMO
       */
      symbol: string;
      /**
       * @description Logo of the source asset of this step
       * @example https://server.com/osmo.png
       */
      logo: string;
      /**
       * @description Logo of blockchain
       * @example https://server.com/osmo.png
       */
      blockchainLogo: string;
      /**
       * @description Contract address of the source asset of this step, null for native tokens
       * @example 0x3232de...ef33
       */
      address?: string;
      /**
       * @description Blockchain of the source asset of this step
       * @example OSMOSIS
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * Format: int32
       * @description Decimals of the source asset of this step
       * @example 18
       */
      decimals: number;
      /**
       * Format: double
       * @description USD price of this asset
       * @example 1.032
       */
      usdPrice?: number;
    };
    /** @description Internal mechanism of a step */
    SwapRoute: {
      /** @description List of parallel paths that splitting happens */
      nodes?: components["schemas"]["SwapSuperNode"][];
    };
    /** @description A path from X to Y */
    SwapSuperNode: {
      /** @description List of intermediate assets that X is swapped to before swapping to Y */
      nodes: components["schemas"]["SwapNode"][];
      /**
       * @description Symbol of source asset
       * @example BTC
       */
      from: string;
      /**
       * @description Address of logo of source asset
       * @example https://server.com/btc.png
       */
      fromLogo: string;
      /**
       * @description Contract address of source asset, null for native tokens
       * @example 0x323afe...3e2
       */
      fromAddress?: string;
      /**
       * @description Blockchain of source asset
       * @example OSMOSIS
       * @enum {string}
       */
      fromBlockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description Symbol of destination asset
       * @example ETH
       */
      to: string;
      /**
       * @description Address of logo of destination asset
       * @example https://server.com/eth.png
       */
      toLogo: string;
      /**
       * @description Contract address of destination asset, null for native tokens
       * @example 0x323afe...3e2
       */
      toAddress?: string;
      /**
       * @description Blockchain of destination asset
       * @example AKASH
       * @enum {string}
       */
      toBlockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
    };
    /** @description Swapper execution estimation times */
    SwapperTimeStat: {
      /**
       * Format: int32
       * @description Minimum amount of seconds that usually take to execute transaction
       */
      min: number;
      /**
       * Format: int32
       * @description Average amount of seconds that usually take to execute transaction
       */
      avg: number;
      /**
       * Format: int32
       * @description Maximum amount of seconds that usually take to execute transaction
       */
      max: number;
    };
    /** @description Describing a required Asset for swapping X to Y and that the wallet has enough balance or not */
    WalletRequiredAsset: {
      asset: components["schemas"]["Asset"];
      requiredAmount: components["schemas"]["Amount"];
      currentAmount: components["schemas"]["Amount"];
      /**
       * @description The reason that Rango needs this asset to be present, ex: fee, input asset, or both
       * @enum {string}
       */
      reason: "FEE" | "INPUT_ASSET" | "FEE_AND_INPUT_ASSET";
      /** @description If true, means this requirement is fulfilled, false means swap may fail due to insufficient balance */
      ok: boolean;
    };
    /** @description The validation status of a wallet */
    WalletValidationStatus: {
      /** @description The address of wallet */
      address: string;
      /** @description The list of required assets for swapping X to Y in this wallet and the status to indicate whether these assets are missing or not */
      requiredAssets: components["schemas"]["WalletRequiredAsset"][];
      /** @description If false, the wallet address is invalid for the given blockchain */
      addressIsValid: boolean;
      /** @description If false, Rango was unable to fetch the balance of this address to check the requiredAssets availability */
      validResult: boolean;
    };
    /** @description Best route request's body */
    BestRouteRequest: {
      from: components["schemas"]["Asset"];
      to: components["schemas"]["Asset"];
      /**
       * @description The human-readable amount of asset X that is going to be swapped
       * @example 0.28
       */
      amount: string;
      /** @description The list of all connected wallets of user in all blockchains */
      connectedWallets?: components["schemas"]["UserWalletBlockchain"][];
      /**
       * @description The list of user's selected wallets to doing the swapping operation. (Blockchain to Wallet address map)
       * @default {}
       * @example {
       *       "ETH": "0x6f33bb1763eebead07cf8815a62fcd7b30311fa3"
       *     }
       */
      selectedWallets: {
        [key: string]: string | undefined;
      };
      /**
       * @description The address of custom destination wallet, in case that you want to just swap in a blockchain because selected wallets can not support this scenario
       * @default null
       * @example 0x6f33bb1763eebead07cf8815a62fcd7b30311fa3
       */
      destination: string;
      /**
       * @description This field should be false when the client wants to preview the route to the user and true when the user accepts the swap. If true, the server will be much slower to respond but will check some prerequisites, including the balance of X and any required fees in the user's wallets.
       * @default false
       * @example false
       */
      checkPrerequisites: boolean;
      /**
       * @description The affiliate ref, which the client likes to send to Rango, so in cases of 1inch, Thorchain, etc., that support affiliation, the client will earn some money if the user accepts the route and signs the transaction.
       * @example K3ldk3
       */
      affiliateRef?: string;
      /**
       * @description List of affiliate wallets per blockchain for referral rewards
       * @example {
       *       "ETH": "0x0000000000000000000000000000000000000000",
       *       "BTC": "bc1qc4adajeqvlujsah02dg2ky8hynhaqlg7ds0mar"
       *     }
       */
      affiliateWallets?: {
        [key: string]: string | undefined;
      };
      /**
       * Format: double
       * @description Affiliate reward for affiliator in percent (1.0 = %1.0), must be less than 1.0 percent
       * @example 0.5
       */
      affiliatePercent?: number;
      /** @description This field is the list of all accepted transaction types. (including EVM, TRANSFER, COSMOS, and SOLANA). An empty list means no filter is required. */
      transactionTypes?: (
        | "EVM"
        | "TRANSFER"
        | "COSMOS"
        | "SOLANA"
        | "ZK_ROLLUP"
        | "TRON"
        | "STARKNET"
      )[];
      /** @description The list of all accepted swappers. An empty list means no filter is required */
      swappers?: string[];
      /** @description Defines the provided swappers as the include/exclude list. Default is false (include) */
      swappersExclude?: boolean;
      /** @description The list of all included/excluded swappers based on tag, empty list means no filter is required */
      swapperGroups?: string[];
      /** @description Defines the provided swappers' tags as the include/exclude list. Default is false (include) */
      swappersGroupsExclude?: boolean;
      /** @description The list of all accepted blockchains. An empty list means no filter is required */
      blockchains?: (
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM"
      )[];
      /** @description Defines the provided blockchains as the include/exclude list. Default is false (include) */
      blockchainsExclude?: boolean;
      /** @description It should be true when client don't want multi step transactions */
      disableMultiStepTx?: boolean;
      /**
       * Format: int32
       * @description Maximum acceptable length of path
       */
      maxLength?: number;
      intraChainMessage?: components["schemas"]["IntraChainMessage"];
      /** @description List of messaging protocols to be used for passing intrachain message */
      messagingProtocols?: (
        | "CBRIDGE"
        | "ANYCALL"
        | "SATELLITE"
        | "LAYER_ZERO"
        | "WORMHOLE"
      )[];
      /** @description set this parameter to `true` if you wants to send transactions through a contract */
      contractCall?: boolean;
      /**
       * @description Amount of user's preferred slippage in percent
       * @example 3
       */
      slippage?: number;
      /** @description Specify that centralized swappers must be included in swappers or not. Default is false (exclude) */
      enableCentralizedSwappers?: boolean;
      /** @description When it is true, Swappers that have native tokens as fee must be excluded. example: when you call it from AA account. */
      avoidNativeFee?: boolean;
    };
    /** @description Info about intrachain message (Source & Destination contracts and IM Message) for cross-chain messaging */
    IntraChainMessage: {
      imMessage: string;
      sourceContract: string;
      destinationContract: string;
    };
    /** @description All wallets of a specific blockchain */
    UserWalletBlockchain: {
      /**
       * @description The blockchain that wallets belong to
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description List of wallet address of the specified blockchain
       * @example 0x6f33bb1763eebead07cf8815a62fcd7b30311fa3
       */
      addresses: string[];
    };
    /** @description The best route response was found by Rango. If the `result` field is null, the server hasn't found any route. */
    MultiRouteResponse: {
      from: components["schemas"]["Asset"];
      to: components["schemas"]["Asset"];
      /**
       * @description The amount from request
       * @example 0.28
       */
      requestAmount: number;
      /** @description The unique roteId generated for this request by server. */
      routeId: string;
      /** @description list of best paths data, null value indicates that no route found */
      results?: components["schemas"]["MultiRouteSimulationResult"][];
      /** @description A warning that indicates that it took too much time to find the best route and server could not find any routes from X to Y */
      processingLimitReached: boolean;
      /** @description A list of string messages that might be cause of not finding the route. It's just for display purposes */
      diagnosisMessages: string[];
      /** @description Error occurred during creating swap */
      error?: string;
      /**
       * Format: int32
       * @description Error code show error type in rango
       */
      errorCode?: number;
      /**
       * Format: int32
       * @description Trace id help rang support to resolve issue
       */
      traceId?: number;
    };
    /** @description Pair of the asset and its amount in the wallet */
    AssetAndAmount: {
      asset: components["schemas"]["Asset"];
      amount: components["schemas"]["Amount"];
    };
    /** @description A wallet's details */
    WalletDetails: {
      /**
       * @description The blockchain which this wallet belongs to
       * @example BSC
       * @enum {string}
       */
      blockChain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description Address of the wallet
       * @example 0x9F8cCdaFCc39F3c7D6EBf637c9151673CBc36b88
       */
      address: string;
      /**
       * @description If it's true, it means that Rango could not fetch this wallet's balance; maybe trying again later could solve the problem.
       * @example false
       */
      failed: boolean;
      /**
       * @description The explorer url of the wallet, e.g. bscscan or harmony explorer
       * @example https://bscscan.com/address/0x9F8cCdaFCc39F3c7D6EBf637c9151673CBc36b88
       */
      explorerUrl: string;
      /** @description Balance of the wallet, null value means server failed to fetch balances, empty list indicates that the wallet is empty */
      balances?: components["schemas"]["AssetAndAmount"][];
    };
    /** @description A list of wallets details */
    WalletDetailsResponse: {
      wallets: components["schemas"]["WalletDetails"][];
    };
    /** @description Check-approval response */
    CheckApprovalResponse: {
      /**
       * @description A flag indicating whether the approve tx was successful or not
       * @example true
       */
      isApproved: boolean;
      /**
       * @description Status of given txId
       * @example running, failed, success, null
       * @enum {string}
       */
      txStatus?: "running" | "failed" | "success";
      /**
       * @description Current approved amount
       * @example 8
       */
      currentApprovedAmount?: number;
      /**
       * @description Required approve amount
       * @example 10
       */
      requiredApprovedAmount?: number;
    };
    /**
     * @description Blockchain extra information
     * @example {
     *       "chainName": "Ethereum Mainnet",
     *       "nativeCurrency": {
     *         "name": "ETH",
     *         "symbol": "ETH",
     *         "decimals": 18
     *       },
     *       "rpcUrls": [
     *         "https://rpc.ankr.com/eth"
     *       ],
     *       "blockExplorerUrls": [
     *         "https://etherscan.io"
     *       ],
     *       "addressUrl": "https://etherscan.io/address/{wallet}",
     *       "transactionUrl": "https://etherscan.io/tx/{txHash}"
     *     }
     */
    AbstractBlockchainMetaInfo: {
      infoType: string;
    };
    /** @description List of all supported blockchains */
    BlockchainMeta: {
      /**
       * @description Unique name of blockchain, this field is used in all endpoints as the identifier of blockchain
       * @example ETH
       */
      name: string;
      /**
       * Format: int32
       * @description The default decimals of blockchain, do not use it in computations, use Token.decimals instead
       * @example 18
       */
      defaultDecimals: number;
      /**
       * @description List of all regex patterns for wallet addresses of this blockchain, can be used for input validation
       * @example [
       *       "^(0x)[0-9A-Fa-f]{40}$"
       *     ]
       */
      addressPatterns: string[];
      /**
       * @description List of assets that can be used as fee in this blockchain
       * @example [
       *       {
       *         "blockchain": "ETH",
       *         "symbol": "ETH",
       *         "address": null
       *       }
       *     ]
       */
      feeAssets: components["schemas"]["Asset"][];
      /**
       * @description Asset logo address
       * @example https://api.rango.exchange/blockchains/ethereum.svg
       */
      logo: string;
      /**
       * @description Blockchain name
       * @example Ethereum
       */
      displayName: string;
      /**
       * @description Blockchain short name
       * @example ETH
       */
      shortName: string;
      /**
       * Format: int32
       * @description Blockchain index in response list
       * @example 3
       */
      sort: number;
      /**
       * @description Blockchain theme color
       * @example #ecf0f1
       */
      color: string;
      /**
       * @description If blockchain server is enabled
       * @example true
       */
      enabled: boolean;
      /**
       * @description Blockchain transaction type. e.g. EVM
       * @example EVM
       * @enum {string}
       */
      type:
        | "EVM"
        | "TRANSFER"
        | "COSMOS"
        | "SOLANA"
        | "ZK_ROLLUP"
        | "TRON"
        | "STARKNET";
      /**
       * @description Blockchain chain id in hex
       * @example 0x1
       */
      chainId?: string;
      info?:
        | components["schemas"]["CosmosMetaInfo"]
        | components["schemas"]["EvmMetaInfo"]
        | components["schemas"]["SolanaMetaInfo"]
        | components["schemas"]["StarkNetMetaInfo"]
        | components["schemas"]["TransferMetaInfo"];
    };
    BlockchainNativeCurrency: {
      name: string;
      symbol: string;
      /** Format: int32 */
      decimals: number;
    };
    CosmosChainBech32Config: {
      bech32PrefixAccAddr: string;
      bech32PrefixAccPub: string;
      bech32PrefixValAddr: string;
      bech32PrefixValPub: string;
      bech32PrefixConsAddr: string;
      bech32PrefixConsPub: string;
    };
    CosmosChainBip44: {
      /** Format: int32 */
      coinType: number;
    };
    CosmosChainCurrency: {
      coinDenom: string;
      coinMinimalDenom: string;
      /** Format: int32 */
      coinDecimals: number;
      coinGeckoId: string;
      coinImageUrl: string;
    };
    CosmosChainStakeCurrency: {
      coinDenom: string;
      coinMinimalDenom: string;
      /** Format: int32 */
      coinDecimals: number;
      coinGeckoId: string;
      coinImageUrl: string;
    };
    CosmosGasPriceStep: {
      /** Format: double */
      low: number;
      /** Format: double */
      average: number;
      /** Format: double */
      high: number;
    };
    CosmosMetaInfo: {
      infoType: "CosmosMetaInfo";
    } & (Omit<
      components["schemas"]["AbstractBlockchainMetaInfo"],
      "infoType"
    > & {
      experimental: boolean;
      rpc: string;
      rest: string;
      cosmostationLcdUrl?: string;
      cosmostationApiUrl?: string;
      cosmostationDenomTracePath: string;
      mintScanName?: string;
      chainName: string;
      stakeCurrency: components["schemas"]["CosmosChainStakeCurrency"];
      bip44: components["schemas"]["CosmosChainBip44"];
      bech32Config: components["schemas"]["CosmosChainBech32Config"];
      currencies: components["schemas"]["CosmosChainCurrency"][];
      feeCurrencies: components["schemas"]["CosmosChainCurrency"][];
      features: string[];
      explorerUrlToTx: string;
      gasPriceStep?: components["schemas"]["CosmosGasPriceStep"];
    });
    EvmMetaInfo: {
      infoType: "EvmMetaInfo";
    } & (Omit<
      components["schemas"]["AbstractBlockchainMetaInfo"],
      "infoType"
    > & {
      chainName: string;
      nativeCurrency: components["schemas"]["BlockchainNativeCurrency"];
      rpcUrls: string[];
      blockExplorerUrls: string[];
      addressUrl: string;
      transactionUrl: string;
      enableGasV2: boolean;
    });
    /** @description A wrapper class for all metadata of Rango */
    MetaResponse: {
      /** @description List of all tokens */
      tokens: components["schemas"]["Token"][];
      /** @description List of popular tokens, a subset of tokens field */
      popularTokens: components["schemas"]["Token"][];
      /** @description List of all supported blockchains */
      blockchains: components["schemas"]["BlockchainMeta"][];
      /** @description List of all DEXes & Bridges */
      swappers: components["schemas"]["SwapperMetaDto"][];
    };
    SolanaMetaInfo: {
      infoType: "SolanaMetaInfo";
    } & Omit<components["schemas"]["AbstractBlockchainMetaInfo"], "infoType">;
    StarkNetMetaInfo: {
      infoType: "StarkNetMetaInfo";
    } & (Omit<
      components["schemas"]["AbstractBlockchainMetaInfo"],
      "infoType"
    > & {
      chainName: string;
      nativeCurrency: components["schemas"]["BlockchainNativeCurrency"];
      blockExplorerUrls: string[];
      addressUrl: string;
      transactionUrl: string;
    });
    /** @description Metadata of Swapper */
    SwapperMetaDto: {
      id: string;
      title: string;
      logo: string;
      swapperGroup: string;
      types?: ("BRIDGE" | "DEX" | "AGGREGATOR" | "OFF_CHAIN")[];
      enabled: boolean;
    };
    /** @description All metadata of a token, unique by (blockchain, symbol, address) tuple */
    Token: {
      /**
       * @description The blockchain which this token belongs to
       * @example ETH
       * @enum {string}
       */
      blockchain:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description The display symbol, e.g. USDT, BTC, etc.
       * @example USDC
       */
      symbol: string;
      /**
       * @description Url of its image
       * @example https://api.rango.exchange/tokens/ETH/USDC.png
       */
      image: string;
      /**
       * @description Smart contract address of token, null for native tokens
       * @example 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
       */
      address?: string;
      /**
       * Format: double
       * @description USD unit price of this token if available
       * @example 1
       */
      usdPrice?: number;
      /**
       * Format: int32
       * @description Decimals of token in blockchain
       * @example 6
       */
      decimals?: number;
      /**
       * @description Display name of token, e.g: `Cardano` for ADA. It can be null
       * @example Binance Pegged USD Coin
       */
      name?: string;
      /**
       * @description If true, means that the token is popular token on the blockchain
       * @example false
       */
      isPopular: boolean;
      /**
       * @description If true, means that the token's trading is high risk. Better to warn user before proceeding
       * @example false
       */
      isSecondaryCoin: boolean;
      /**
       * @description If the token is secondary, coinSource indicates the third-party list that Rango found this token in
       * @example Pancake Extended List
       */
      coinSource?: string;
      /**
       * @description The url of the list that token was extracted from
       * @example https://defiprime.com/defiprime.tokenlist.json
       */
      coinSourceUrl?: string;
      /**
       * @description Supported swappers for this token
       * @example [
       *       "oneInch"
       *     ]
       */
      supportedSwappers: string[];
    };
    TransferMetaInfo: {
      infoType: "TransferMetaInfo";
    } & Omit<components["schemas"]["AbstractBlockchainMetaInfo"], "infoType">;
    /** @description Metadata of Swapper */
    SwapperMetaFullDto: {
      id: string;
      title: string;
      logo: string;
      swapperGroup: string;
      types?: ("BRIDGE" | "DEX" | "AGGREGATOR" | "OFF_CHAIN")[];
      enabled: boolean;
      supportedBlockchains: components["schemas"]["SwapperSupportedBlockchain"][];
    };
    /** @description Supported blockchains of Swapper */
    SwapperSupportedBlockchain: {
      /** @enum {string} */
      source:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      destinations: (
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM"
      )[];
    };
    /** @description A wrapper class for all metadata of Rango */
    MetaCompactResponse: {
      /** @description List of all tokens */
      tokens: components["schemas"]["TokenCompact"][];
      /** @description List of popular tokens, a subset of tokens field */
      popularTokens: components["schemas"]["TokenCompact"][];
      /** @description List of all supported blockchains */
      blockchains: components["schemas"]["BlockchainMeta"][];
      /** @description List of all DEXes & Bridges */
      swappers: components["schemas"]["SwapperMetaDto"][];
    };
    /** @description All metadata of a token, unique by (blockchain, symbol, address) tuple */
    TokenCompact: {
      /**
       * @description The blockchain which this token belongs to
       * @example ETH
       * @enum {string}
       */
      b:
        | "ETH"
        | "BSC"
        | "ARBITRUM"
        | "POLYGON"
        | "ZKSYNC"
        | "STARKNET"
        | "OPTIMISM"
        | "AVAX_CCHAIN"
        | "POLYGONZK"
        | "BASE"
        | "LINEA"
        | "TRON"
        | "BTC"
        | "SCROLL"
        | "BLAST"
        | "COSMOS"
        | "OSMOSIS"
        | "NEUTRON"
        | "NOBLE"
        | "DYDX"
        | "SOLANA"
        | "CRONOS"
        | "BNB"
        | "FANTOM"
        | "AURORA"
        | "MAYA"
        | "THOR"
        | "BOBA"
        | "MOONBEAM"
        | "MOONRIVER"
        | "OKC"
        | "BOBA_BNB"
        | "BOBA_AVALANCHE"
        | "LTC"
        | "BCH"
        | "HARMONY"
        | "EVMOS"
        | "HECO"
        | "METIS"
        | "SIF"
        | "BRISE"
        | "STARGAZE"
        | "FUSE"
        | "CRYPTO_ORG"
        | "CHIHUAHUA"
        | "BANDCHAIN"
        | "COMDEX"
        | "REGEN"
        | "IRIS"
        | "EMONEY"
        | "GNOSIS"
        | "JUNO"
        | "AXELAR"
        | "STRIDE"
        | "KCC"
        | "MARS"
        | "TERRA"
        | "TELOS"
        | "BITSONG"
        | "AKASH"
        | "KI"
        | "PERSISTENCE"
        | "MEDIBLOC"
        | "KUJIRA"
        | "SENTINEL"
        | "INJECTIVE"
        | "SECRET"
        | "KONSTELLATION"
        | "STARNAME"
        | "BITCANNA"
        | "UMEE"
        | "DESMOS"
        | "LUMNETWORK"
        | "TERRA_CLASSIC"
        | "CELO"
        | "DASH"
        | "POLKADOT"
        | "DOGE"
        | "GOERLI"
        | "GOERLI_ARBITRUM"
        | "GOERLI_OPTIMISM";
      /**
       * @description The display symbol, e.g. USDT, BTC, etc.
       * @example USDC
       */
      s: string;
      /**
       * @description Url of its image
       * @example https://api.rango.exchange/tokens/ETH/USDC.png
       */
      i: string;
      /**
       * @description Smart contract address of token, null for native tokens
       * @example 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
       */
      a?: string;
      /**
       * Format: double
       * @description USD unit price of this token if available
       * @example 1
       */
      p?: number;
      /**
       * Format: int32
       * @description Decimals of token in blockchain
       * @example 6
       */
      d?: number;
      /**
       * @description Display name of token, e.g: `Cardano` for ADA. It can be null
       * @example Cardano
       */
      n?: string;
      /**
       * @description If true, means that the token is popular token on the blockchain
       * @example false
       */
      ip?: boolean;
      /**
       * @description If true, means that the token's trading is high risk. Better to warn user before proceeding
       * @example false
       */
      is?: boolean;
      /**
       * @description If the token is secondary, coinSource indicates the third-party list that Rango found this token in
       * @example Pancake Extended List
       */
      c?: string;
      /**
       * @description The url of the list that token was extracted from
       * @example https://defiprime.com/defiprime.tokenlist.json
       */
      cu?: string;
      /**
       * @description Supported swappers for this token
       * @example [
       *       "oneInch"
       *     ]
       */
      ss: string[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  reportTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReportTransactionRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTransactionRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["CreateTransactionResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkTxStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CheckTxStatusRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["TransactionStatusResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmSwap: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfirmSwapRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["ConfirmSwapResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBestRoutes: {
    parameters: {
      query?: never;
      header?: {
        /** @example xlkewlkjewlk1 */
        "X-Rango-Id"?: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BestRouteRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["MultiRouteResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBestRoute: {
    parameters: {
      query?: never;
      header?: {
        /** @example xlkewlkjewlk1 */
        "X-Rango-Id"?: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BestRouteRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["BestRouteResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTokenBalance: {
    parameters: {
      query: {
        /**
         * @description User's wallet address
         * @example 0x9F8cCdaFCc39F3c7D6EBf637c9151673CBc36b88
         */
        walletAddress: string;
        /**
         * @description Blockchain
         * @example BSC
         */
        blockchain:
          | "ETH"
          | "BSC"
          | "ARBITRUM"
          | "POLYGON"
          | "ZKSYNC"
          | "STARKNET"
          | "OPTIMISM"
          | "AVAX_CCHAIN"
          | "POLYGONZK"
          | "BASE"
          | "LINEA"
          | "TRON"
          | "BTC"
          | "SCROLL"
          | "BLAST"
          | "COSMOS"
          | "OSMOSIS"
          | "NEUTRON"
          | "NOBLE"
          | "DYDX"
          | "SOLANA"
          | "CRONOS"
          | "BNB"
          | "FANTOM"
          | "AURORA"
          | "MAYA"
          | "THOR"
          | "BOBA"
          | "MOONBEAM"
          | "MOONRIVER"
          | "OKC"
          | "BOBA_BNB"
          | "BOBA_AVALANCHE"
          | "LTC"
          | "BCH"
          | "HARMONY"
          | "EVMOS"
          | "HECO"
          | "METIS"
          | "SIF"
          | "BRISE"
          | "STARGAZE"
          | "FUSE"
          | "CRYPTO_ORG"
          | "CHIHUAHUA"
          | "BANDCHAIN"
          | "COMDEX"
          | "REGEN"
          | "IRIS"
          | "EMONEY"
          | "GNOSIS"
          | "JUNO"
          | "AXELAR"
          | "STRIDE"
          | "KCC"
          | "MARS"
          | "TERRA"
          | "TELOS"
          | "BITSONG"
          | "AKASH"
          | "KI"
          | "PERSISTENCE"
          | "MEDIBLOC"
          | "KUJIRA"
          | "SENTINEL"
          | "INJECTIVE"
          | "SECRET"
          | "KONSTELLATION"
          | "STARNAME"
          | "BITCANNA"
          | "UMEE"
          | "DESMOS"
          | "LUMNETWORK"
          | "TERRA_CLASSIC"
          | "CELO"
          | "DASH"
          | "POLKADOT"
          | "DOGE"
          | "GOERLI"
          | "GOERLI_ARBITRUM"
          | "GOERLI_OPTIMISM";
        /**
         * @description Token Symbol
         * @example USDT
         */
        symbol: string;
        /**
         * @description Token Address (Not required for native tokens)
         * @example 0x9F8cCdaFCc39F3c7D6EBf637c9151673CBc36b88
         */
        address?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": number;
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getWalletDetails: {
    parameters: {
      query: {
        /** @description A list of Blockchains and addresses separated by a dot(.) */
        address: string[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["WalletDetailsResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkApproval: {
    parameters: {
      query?: {
        /**
         * @description Approve transaction tx id
         * @example 0x7f17aaba51d1f24204cd8b02251001d3704add46d84840a5826b95ef49b8b74f
         */
        txId?: string;
      };
      header?: never;
      path: {
        /**
         * @description Unique ID generated by `best route` endpoint
         * @example b3a12c6d-86b8-4c21-97e4-809151dd4036
         */
        requestId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["CheckApprovalResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAllMeta: {
    parameters: {
      query?: {
        /** @description The list of all accepted blockchains. An empty list means no filter is required */
        blockchains?: (
          | "ETH"
          | "BSC"
          | "ARBITRUM"
          | "POLYGON"
          | "ZKSYNC"
          | "STARKNET"
          | "OPTIMISM"
          | "AVAX_CCHAIN"
          | "POLYGONZK"
          | "BASE"
          | "LINEA"
          | "TRON"
          | "BTC"
          | "SCROLL"
          | "BLAST"
          | "COSMOS"
          | "OSMOSIS"
          | "NEUTRON"
          | "NOBLE"
          | "DYDX"
          | "SOLANA"
          | "CRONOS"
          | "BNB"
          | "FANTOM"
          | "AURORA"
          | "MAYA"
          | "THOR"
          | "BOBA"
          | "MOONBEAM"
          | "MOONRIVER"
          | "OKC"
          | "BOBA_BNB"
          | "BOBA_AVALANCHE"
          | "LTC"
          | "BCH"
          | "HARMONY"
          | "EVMOS"
          | "HECO"
          | "METIS"
          | "SIF"
          | "BRISE"
          | "STARGAZE"
          | "FUSE"
          | "CRYPTO_ORG"
          | "CHIHUAHUA"
          | "BANDCHAIN"
          | "COMDEX"
          | "REGEN"
          | "IRIS"
          | "EMONEY"
          | "GNOSIS"
          | "JUNO"
          | "AXELAR"
          | "STRIDE"
          | "KCC"
          | "MARS"
          | "TERRA"
          | "TELOS"
          | "BITSONG"
          | "AKASH"
          | "KI"
          | "PERSISTENCE"
          | "MEDIBLOC"
          | "KUJIRA"
          | "SENTINEL"
          | "INJECTIVE"
          | "SECRET"
          | "KONSTELLATION"
          | "STARNAME"
          | "BITCANNA"
          | "UMEE"
          | "DESMOS"
          | "LUMNETWORK"
          | "TERRA_CLASSIC"
          | "CELO"
          | "DASH"
          | "POLKADOT"
          | "DOGE"
          | "GOERLI"
          | "GOERLI_ARBITRUM"
          | "GOERLI_OPTIMISM"
        )[];
        /** @description Defines the provided blockchains as the include/exclude list. Default is false (include) */
        blockchainsExclude?: boolean;
        /** @description The list of all accepted swappers. An empty list means no filter is required */
        swappers?: string[];
        /** @description Defines the provided swappers as the include/exclude list. Default is false (include) */
        swappersExclude?: boolean;
        /** @description The list of all included/excluded swappers based on tag, empty list means no filter is required */
        swapperGroups?: string[];
        /** @description Defines the provided swappers' tags as the include/exclude list. Default is false (include) */
        swappersGroupsExclude?: boolean;
        /**
         * @description Blockchain Type
         * @example EVM
         */
        transactionTypes?: (
          | "EVM"
          | "TRANSFER"
          | "COSMOS"
          | "SOLANA"
          | "ZK_ROLLUP"
          | "TRON"
          | "STARKNET"
        )[];
        /** @description Defines the provided swappers' tags as the include/exclude list. Default is false (include) */
        transactionTypesExclude?: boolean;
        /** @description Exclude secondary tokens. Default is false (include) */
        excludeSecondaries?: boolean;
        /** @description Exclude non popular tokens. Default is false (include) */
        excludeNonPopulars?: boolean;
        /** @description Specify that centralized swappers must be included in swappers or not. Default is false (exclude) */
        enableCentralizedSwappers?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["MetaResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSwappers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["SwapperMetaFullDto"][];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAllMetaCompact: {
    parameters: {
      query?: {
        /** @description The list of all accepted blockchains. An empty list means no filter is required */
        blockchains?: (
          | "ETH"
          | "BSC"
          | "ARBITRUM"
          | "POLYGON"
          | "ZKSYNC"
          | "STARKNET"
          | "OPTIMISM"
          | "AVAX_CCHAIN"
          | "POLYGONZK"
          | "BASE"
          | "LINEA"
          | "TRON"
          | "BTC"
          | "SCROLL"
          | "BLAST"
          | "COSMOS"
          | "OSMOSIS"
          | "NEUTRON"
          | "NOBLE"
          | "DYDX"
          | "SOLANA"
          | "CRONOS"
          | "BNB"
          | "FANTOM"
          | "AURORA"
          | "MAYA"
          | "THOR"
          | "BOBA"
          | "MOONBEAM"
          | "MOONRIVER"
          | "OKC"
          | "BOBA_BNB"
          | "BOBA_AVALANCHE"
          | "LTC"
          | "BCH"
          | "HARMONY"
          | "EVMOS"
          | "HECO"
          | "METIS"
          | "SIF"
          | "BRISE"
          | "STARGAZE"
          | "FUSE"
          | "CRYPTO_ORG"
          | "CHIHUAHUA"
          | "BANDCHAIN"
          | "COMDEX"
          | "REGEN"
          | "IRIS"
          | "EMONEY"
          | "GNOSIS"
          | "JUNO"
          | "AXELAR"
          | "STRIDE"
          | "KCC"
          | "MARS"
          | "TERRA"
          | "TELOS"
          | "BITSONG"
          | "AKASH"
          | "KI"
          | "PERSISTENCE"
          | "MEDIBLOC"
          | "KUJIRA"
          | "SENTINEL"
          | "INJECTIVE"
          | "SECRET"
          | "KONSTELLATION"
          | "STARNAME"
          | "BITCANNA"
          | "UMEE"
          | "DESMOS"
          | "LUMNETWORK"
          | "TERRA_CLASSIC"
          | "CELO"
          | "DASH"
          | "POLKADOT"
          | "DOGE"
          | "GOERLI"
          | "GOERLI_ARBITRUM"
          | "GOERLI_OPTIMISM"
        )[];
        /** @description Defines the provided blockchains as the include/exclude list. Default is false (include) */
        blockchainsExclude?: boolean;
        /** @description The list of all accepted swappers. An empty list means no filter is required */
        swappers?: string[];
        /** @description Defines the provided swappers as the include/exclude list. Default is false (include) */
        swappersExclude?: boolean;
        /** @description The list of all included/excluded swappers based on tag, empty list means no filter is required */
        swapperGroups?: string[];
        /** @description Defines the provided swappers' tags as the include/exclude list. Default is false (include) */
        swappersGroupsExclude?: boolean;
        /**
         * @description Blockchain Type
         * @example EVM
         */
        transactionTypes?: (
          | "EVM"
          | "TRANSFER"
          | "COSMOS"
          | "SOLANA"
          | "ZK_ROLLUP"
          | "TRON"
          | "STARKNET"
        )[];
        /** @description Defines the provided swappers' tags as the include/exclude list. Default is false (include) */
        transactionTypesExclude?: boolean;
        /** @description Exclude secondary tokens. Default is false (include) */
        excludeSecondaries?: boolean;
        /** @description Exclude non popular tokens. Default is false (include) */
        excludeNonPopulars?: boolean;
        /** @description Specify that supported swappers must be included in swappers or not. Default is false (include) */
        ignoreSupportedSwappers?: boolean;
        /** @description Specify that centralized swappers must be included in swappers or not. Default is false (exclude) */
        enableCentralizedSwappers?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["MetaCompactResponse"];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBlockchains: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["BlockchainMeta"][];
        };
      };
      /** @description Bad client request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
type WithRequired<T, K extends keyof T> = T & {
  [P in K]-?: T[P];
};
